--[[ global vars ]]--
rrixh = loadstring;
lulas = game;
_G.plrs = game:GetService"Players"
_G.plr = _G.plrs.LocalPlayer
_G.char = _G.plr.Character
_G.hum = _G.char:WaitForChild'Humanoid';
_G.hrp = _G.char:FindFirstChild'HumanoidRootPart';

--[[ servixes ]]--
_G.run = lulas:GetService'RunService'
_G.vim = lulas:GetService'VirtualInputManager'
_G.uis = lulas:GetService'UserInputService'

--[[ global funks ]]--
_G.bezier = function(t, p0, p1, p2)
local l1 = p0:Lerp(p1, t)
local l2 = p1:Lerp(p2, t)
return l1:Lerp(l2, t)
end

_G.tweenTo = function(part, duration)
local player = game.Players.LocalPlayer
local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart");
if not hrp then return end;
local startPos = hrp.Position
local endPos = part.Position
local midPos = (startPos + endPos) / 2 + Vector3.new(math.random(-5, 5), math.random(3, 7), math.random(-5, 5))
local tweenStart = os.clock();
repeat
local elapsed = os.clock() - tweenStart
local t = math.min(elapsed / duration, 1)
local bezierPos = _G.bezier(t, startPos, midPos, endPos);
hrp.CFrame = CFrame.new(bezierPos)
task.wait()
until t >= 1
end;

--simulate touxhing part
_G.touxh = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
firetouchinterest(_G.hrp, part, 0)
if duration then
task.wait(duration)
end;
firetouchinterest(_G.hrp, part, 1)
end;

--tp
_G.tp = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
_G.hrp.CFrame = part.CFrame
if duration then
task.wait(duration)
    end;
end;

_G.bring = function(part, duration)
_G.player = game.Players.LocalPlayer
_G.hrp = _G.player.Character and _G.player.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
part.CFrame = _G.hrp.CFrame;
    if duration then
        task.wait(duration)
    end;
end;

-- moveto
_G.walkTo = function(part, speed)
if not part then
error("You must provide a part to walk to.") 
return end;

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid")

if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end

local originalSpeed = humanoid.WalkSpeed

if type(speed) == "number" then
humanoid.WalkSpeed = speed
end

local PathfindingService = game:GetService("PathfindingService")
local path = PathfindingService:CreatePath({
AgentHeight = humanoid.HipHeight * 2,
AgentRadius = 2,
AgentCanJump = true,
})

path:ComputeAsync(humanoidRootPart.Position, part.Position)
local waypoints = path:GetWaypoints()

for _, waypoint in pairs(waypoints) do
humanoid:MoveTo(waypoint.Position)
humanoid.MoveToFinished:Wait()

if waypoint.Action == Enum.PathWaypointAction.Jump then
humanoid.Jump = true
end
end
-- Restore original walk speed after reaching the target
humanoid.WalkSpeed = originalSpeed
end;

--tpwalk to
_G.tpwalkTo = function(part)
if not part then
error("You must provide a part to teleport walk to.")
return
end;
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid");
if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end;
local stepDistance = 7
local function moveToStep(targetPos)
humanoidRootPart.CFrame = CFrame.new(targetPos)
end;
local startPos = humanoidRootPart.Position
local endPos = part.Position
local direction = (endPos - startPos).unit
local currentPos = startPos;
while (currentPos - endPos).magnitude > stepDistance do
currentPos = currentPos + direction * stepDistance
moveToStep(currentPos)
task.wait(0.01)
end;
moveToStep(endPos)
end;

--i pairs
_G.iPairs = function(part, funk, dur)
for uh,ipair in ipairs(part:GetChildren()) do
    funk(ipair)
if dur then wait(dur) end;
  end
end

-- pairs
_G.Pairs = function(part, funk, dur)
for uh,pair in pairs(part:GetChildren()) do
    funk(pair)
if dur then wait(dur) end;
  end
end;

--[[üñçPREDEFINED KOLORSüñç]]--
red = "red"
green = "green"
blue = "blue"
yellow = "yellow"
pink = "pink"
orange = "orange"
cyan = "cyan"
purple = "purple"
white = "white"
black = "black"
gray = "gray"
brown = "brown"
lime = "lime"
magenta = "magenta"
salmon = "salmon"
teal = "teal"

-- highlight part
local colorVariables = {
  red = "red",
  green = "green",
  blue = "blue",
  yellow = "yellow",
  pink = "pink",
  orange = "orange",
  cyan = "cyan",
  purple = "purple",
  white = "white",
  black = "black",
  gray = "gray",
  brown = "brown",
  lime = "lime",
  magenta = "magenta",
  salmon = "salmon",
  teal = "teal"
}

local colorVariables = {
red = "red",
green = "green",
blue = "blue",
yellow = "yellow",
pink = "pink",
orange = "orange",
cyan = "cyan",
purple = "purple",
white = "white",
black = "black",
gray = "gray",
brown = "brown",
lime = "lime",
magenta = "magenta",
salmon = "salmon",
teal = "teal"
}

_G.activeEspObjects = _G.activeEspObjects or {}

_G.partesp = function(part, colorVar, removeESP)
if not part or not colorVar then
error("Missing part or color for ESP")
return end;
local colorName = colorVariables[colorVar:lower()]
if not colorName then
error("Invalid color variable provided: " .. tostring(colorVar))
return
end;
local colors = {
red = Color3.fromRGB(255, 0, 0),
green = Color3.fromRGB(0, 255, 0),
blue = Color3.fromRGB(0, 0, 255),
yellow = Color3.fromRGB(255, 255, 0),
pink = Color3.fromRGB(255, 192, 203),
orange = Color3.fromRGB(255, 165, 0),
cyan = Color3.fromRGB(0, 255, 255),
purple = Color3.fromRGB(128, 0, 128),
white = Color3.fromRGB(255, 255, 255),
black = Color3.fromRGB(0, 0, 0),
gray = Color3.fromRGB(128, 128, 128),
brown = Color3.fromRGB(165, 42, 42),
lime = Color3.fromRGB(50, 205, 50),
magenta = Color3.fromRGB(255, 0, 255),
salmon = Color3.fromRGB(250, 128, 114),
teal = Color3.fromRGB(0, 128, 128)
}
local espColor = colors[colorName]
if not espColor then
error("Invalid color provided in the script")
return
end;
local existingEsp = _G.activeEspObjects[part]
if existingEsp then
existingEsp:Destroy()
end;
local espHighlight = Instance.new("Highlight")
espHighlight.Adornee = part
espHighlight.FillColor = espColor
espHighlight.FillTransparency = 0.15 -- Default to 0.15 transparency
espHighlight.OutlineTransparency = 0.15 -- Default to 0.15 transparency
espHighlight.Parent = game:GetService("CoreGui");
_G.activeEspObjects[part] = espHighlight
if removeESP then
spawn(function()
wait(removeESP)
espHighlight:Destroy()
_G.activeEspObjects[part] = nil
end)
end;
end;

--[[ ROBLOX INNOVATION AWARDS ]]--
_G.circlet = Workspace:FindFirstChild("Scavenger") and Workspace.Scavenger:FindFirstChild("Circlet")
_G.stagestand = Workspace:FindFirstChild("CenterPiece") and Workspace.CenterPiece:FindFirstChild("CenterPiece_Stand") and Workspace.CenterPiece.CenterPiece_Stand:FindFirstChild("Meshes/Stand_Full_Cylinder.001")
_G.B1 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block1")
_G.B2 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block2")
_G.B3 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block3")
_G.B4 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block4")

_G.rbxinnovationitems = {
_G.B1, _G.B2, _G.B3, _G.B4, _G.stagestand, _G.circlet}

--[[ FONTS ]]--
local fontz = {
arcade = Enum.Font.Arcade,
arial = Enum.Font.Arial,
arialbold = Enum.Font.ArialBold,
cartoon = Enum.Font.Cartoon,
code = Enum.Font.Code,
fantasy = Enum.Font.Fantasy,
gothic = Enum.Font.Gothic,
gotham = Enum.Font.Gotham,
gothamblack = Enum.Font.GothamBlack,
gothambold = Enum.Font.GothamBold,
gothammedium = Enum.Font.GothamMedium,
highway = Enum.Font.Highway,
jura = Enum.Font.Jura,
legacy = Enum.Font.Legacy,
luckiestguy = Enum.Font.LuckiestGuy,
michigan = Enum.Font.Michigan,
oswald = Enum.Font.Oswald,
permanentmarker = Enum.Font.PermanentMarker,
roblox = Enum.Font.Roblox,
robloxcondensed = Enum.Font.RobloxCondensed,
robloxbold = Enum.Font.Roboto,
sci = Enum.Font.SciFi,
sourceSans = Enum.Font.SourceSans,
sourceSansbold = Enum.Font.SourceSansBold,
sourceSansItalic = Enum.Font.SourceSansItalic,
sourceSansItalicBold = Enum.Font.SourceSansItalicBold,
sourceSansLight = Enum.Font.SourceSansLight,
sourceSansRegular = Enum.Font.SourceSansRegular,
sourceSansSemiBold = Enum.Font.SourceSansSemibold,
specialelite = Enum.Font.SpecialElite,
steampunk = Enum.Font.Steampunk,
titilliumweb = Enum.Font.TitilliumWeb,
tryro = Enum.Font.Tryro,
ubuntu = Enum.Font.Ubuntu,
ubuntuBlack = Enum.Font.UbuntuMonoBold,
ubuntuBold = Enum.Font.UbuntuMono,
ubuntuMedium = Enum.Font.UbuntuCondensed,
ugobe = Enum.Font.Ugobe,
ultra = Enum.Font.Ultra,
ubuntuMonoBold = Enum.Font.UbuntuMonoBold,
ubuntuMono = Enum.Font.UbuntuMono,
ubuntuCondensed = Enum.Font.UbuntuCondensed,
};
_G.activeLabelObjects = _G.activeLabelObjects or {};
-- labeltext ona part
_G.partlabel = function(part, fontVar, labelName, removeTracer)
if not part or not fontVar or not labelName then
error("Missing part, font or label name for label")
return end;
local fontName = fontz[fontVar:lower()]
if not fontName then
error("Invalid font variable provided: " .. tostring(fontVar))
return end;
local existingLabel = _G.activeLabelObjects[part]
if existingLabel then
existingLabel:Destroy()
end;
local billboardGui = Instance.new("BillboardGui")
billboardGui.Adornee = part
billboardGui.Size = UDim2.new(1, 0, 1, 0)
billboardGui.StudsOffset = Vector3.new(0, 2, 0)
billboardGui.Parent = game:GetService("CoreGui");
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
textLabel.TextScaled = true
textLabel.Font = fontName
textLabel.Text = labelName
textLabel.Parent = billboardGui;
_G.activeLabelObjects[part] = billboardGui;
if removeTracer then
spawn(function()
wait(removeTracer)
billboardGui:Destroy()
_G.activeLabelObjects[part] = nil
end)
end;
end;