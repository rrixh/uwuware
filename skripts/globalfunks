--[[ global vars ]]--
rrixh = loadstring;
lulas = game;
_G.plrs = game:GetService"Players"
_G.plr = _G.plrs.LocalPlayer
_G.char = _G.plr.Character
_G.hum = _G.char:WaitForChild'Humanoid';
_G.hrp = _G.char:FindFirstChild'HumanoidRootPart';

--[[ servixes ]]--
_G.run = lulas:GetService'RunService'
_G.vim = lulas:GetService'VirtualInputManager'
_G.uis = lulas:GetService'UserInputService'

--[[ global funks ]]--
_G.bezier = function(t, p0, p1, p2)
local l1 = p0:Lerp(p1, t)
local l2 = p1:Lerp(p2, t)
return l1:Lerp(l2, t)
end

_G.tweenTo = function(part, duration)
local player = game.Players.LocalPlayer
local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart");
if not hrp then return end;
local startPos = hrp.Position
local endPos = part.Position
local midPos = (startPos + endPos) / 2 + Vector3.new(math.random(-5, 5), math.random(3, 7), math.random(-5, 5))
local tweenStart = os.clock();
repeat
local elapsed = os.clock() - tweenStart
local t = math.min(elapsed / duration, 1)
local bezierPos = _G.bezier(t, startPos, midPos, endPos);
hrp.CFrame = CFrame.new(bezierPos)
task.wait()
until t >= 1
end;

--simulate touxhing part
_G.touxh = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
firetouchinterest(_G.hrp, part, 0)
if duration then
task.wait(duration)
end;
firetouchinterest(_G.hrp, part, 1)
end;

--tp
_G.tp = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
_G.hrp.CFrame = part.CFrame
if duration then
task.wait(duration)
    end;
end;

_G.bring = function(part, duration)
_G.player = game.Players.LocalPlayer
_G.hrp = _G.player.Character and _G.player.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
part.CFrame = _G.hrp.CFrame;
    if duration then
        task.wait(duration)
    end;
end;

-- moveto
_G.walkTo = function(part, speed)
if not part then
error("You must provide a part to walk to.") 
return end;

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid")

if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end

local originalSpeed = humanoid.WalkSpeed

if type(speed) == "number" then
humanoid.WalkSpeed = speed
end

local PathfindingService = game:GetService("PathfindingService")
local path = PathfindingService:CreatePath({
AgentHeight = humanoid.HipHeight * 2,
AgentRadius = 2,
AgentCanJump = true,
})

path:ComputeAsync(humanoidRootPart.Position, part.Position)
local waypoints = path:GetWaypoints()

for _, waypoint in pairs(waypoints) do
humanoid:MoveTo(waypoint.Position)
humanoid.MoveToFinished:Wait()

if waypoint.Action == Enum.PathWaypointAction.Jump then
humanoid.Jump = true
end
end
-- Restore original walk speed after reaching the target
humanoid.WalkSpeed = originalSpeed
end;

--tpwalk to
_G.tpwalkTo = function(part)
if not part then
error("You must provide a part to teleport walk to.")
return
end;
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid");
if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end;
local stepDistance = 7
local function moveToStep(targetPos)
humanoidRootPart.CFrame = CFrame.new(targetPos)
end;
local startPos = humanoidRootPart.Position
local endPos = part.Position
local direction = (endPos - startPos).unit
local currentPos = startPos;
while (currentPos - endPos).magnitude > stepDistance do
currentPos = currentPos + direction * stepDistance
moveToStep(currentPos)
task.wait(0.01)
end;
moveToStep(endPos)
end;

--i pairs
_G.iPairs = function(part, funk, dur)
for uh,ipair in ipairs(part:GetChildren()) do
    funk(ipair)
if dur then wait(dur) end;
  end
end

-- pairs
_G.Pairs = function(part, funk, dur)
for uh,pair in pairs(part:GetChildren()) do
    funk(pair)
if dur then wait(dur) end;
  end
end;

--[[üñçPREDEFINED KOLORSüñç]]--
red = "red"
green = "green"
blue = "blue"
yellow = "yellow"
pink = "pink"
orange = "orange"
cyan = "cyan"
purple = "purple"
white = "white"
black = "black"
gray = "gray"
brown = "brown"
lime = "lime"
magenta = "magenta"
salmon = "salmon"
teal = "teal"

-- highlight part
_G.partesp = function(part, highlightKolor)
if not part or not highlightKolor then
error("Missing part or highlight color.")
return end;
local colors = {
red = Color3.fromRGB(255, 0, 0),
green = Color3.fromRGB(0, 255, 0),
blue = Color3.fromRGB(0, 0, 255),
yellow = Color3.fromRGB(255, 255, 0),
pink = Color3.fromRGB(255, 105, 180),
orange = Color3.fromRGB(255, 165, 0),
cyan = Color3.fromRGB(0, 255, 255),
purple = Color3.fromRGB(128, 0, 128),
white = Color3.fromRGB(255, 255, 255),
black = Color3.fromRGB(0, 0, 0),
gray = Color3.fromRGB(128, 128, 128),
brown = Color3.fromRGB(139, 69, 19),
lime = Color3.fromRGB(0, 255, 0),
magenta = Color3.fromRGB(255, 0, 255),
salmon = Color3.fromRGB(250, 128, 114),
teal = Color3.fromRGB(0, 128, 128)
};
local highlightColor = colors[highlightKolor]
if not highlightColor then
error("Invalid highlight color specified.")
return end;
local highlight = Instance.new("SelectionBox")
highlight.Adornee = part
highlight.Color3 = highlightColor
highlight.Parent = part
end;