local globals, syntaxerror = pcall(function()

--[[ names/users ]]--
_G.lulas = ('lulaslollipop');
_G.kh3we = ('kh3we');
_G.xheru = ('cherussii');
_G.hg = ('smileszbaby');

-- [[ my soxials ]] --
_G.rbxlink = ("https://www.roblox.com/users/3001347724/profile")
_G.diskordlink = ("https://discordapp.com/users/1284685023630458963")
_G.ytlink = ("https://youtube.com/@rsgmj")
_G.telegramlink = ("https://t.me/sIipped")
_G.iglink = ("instagram.com/mxrylvnd")

-- [[ setting/global vars ]] --
    rrixh = loadstring;
    lulas = game;
    _G.kore = lulas:GetService'CoreGui';
    _G.rbx = lulas;
    _G.game = lulas.PlaceId;
    _G.gamename = game:GetService'MarketplaceService':GetProductInfo(_G.game).Name;
    _G.exp = identifyexecutor();
    _G.plrs = game:GetService'Players';
    _G.plr = _G.plrs.LocalPlayer;
    _G.lp = _G.plrs.LocalPlayer;
    _G.userid = _G.plr.UserId;
    _G.UID = _G.plr.UserId;
    _G.user = _G.plr.Name;
    _G.username = _G.plr.Name;
    _G.display = _G.plr.DisplayName;
    _G.displayname = _G.plr.DisplayName;
    _G.gplrs = _G.plrs:GetPlayers();
    _G.char = _G.plr.Character;
    _G.hum = _G.char:FindFirstChild'Humanoid';
    _G.hrp = _G.char:FindFirstChild'HumanoidRootPart';
    _G.health = _G.hum.Health;
   _G.anim = game.Players.LocalPlayer.Character.Animate;
    _G.kam = workspace.CurrentCamera;
    _G.ws = _G.hum.WalkSpeed;
    _G.jp = _G.hum.JumpPower;
    _G.sit = _G.hum.Sit;
   _G.jump = _G.hum.Jump;
_G.kamera = game.Workspace.CurrentCamera;

-- [[ IMAGES ]] --
_G.cheruimg = (17104316554);
_G.hgimg = (15729672382);
_G.lollypop = (17767487755);
_G.hublogo = (81697484807530);
_G.qlogo = (83208221166718);
_G.nekogirls = (99387651581628);
_G.nekogirlsfull = (129450989114634);
_G.animekatgirl = (18817519330);
_G.turkey = (124622552375747);
_G.xmastree = (83624080780174);
_G.halloween = (111324508198120);
_G.valentines = (99511253993554);
_G.newyears = (140472834812860);
_G.stpatrixks = (110841053352535);
_G.sgx = (92354585685421);

--[[ invalids(10) ]]--
_G.invalid = {"ggerrtasalt", "", " ", "  ", "   ", "    ", "     ", "      ", "       ", "        ", "         ", "          "}

    --[[ servixes ]]--
    _G.run = lulas:GetService'RunService';
    _G.rep = lulas:GetService'ReplicatedStorage';
    _G.vim = lulas:GetService'VirtualInputManager';
    _G.uis = lulas:GetService'UserInputService';
    _G.w = lulas:GetService'Workspace';
   _G.pps = game:GetService'ProximityPromptService';
   _G.tps = game:GetService'TeleportService';
   _G.sgui = game:GetService'StarterGui';

-- [[ TO ENABLE TEXTXHATSERVIXE ]] --
--[[
if getgenv().textcs then 
_G.tcs = game:GetService'TextChatService'
   else 
print("Globals/Servixe: getgenv().textcs = false");
end;
]]--

-- [[ SHORTKUT KONNEKTIONS ]] --
   _G.ppshown = _G.pps.PromptShown;
   _G.pptriggered = _G.pps.PromptTriggered;
_G.renderstepped = _G.run.RenderStepped;
  _G.stepped = _G.run.Stepped;
_G.heartbeat = _G.run.Heartbeat;
_G.hb = _G.heartbeat;
_G.chatted = _G.plr.Chatted;

-- [[ EXEKUTORS ]] --
local delta, Delta, DELTA = "Delta", "Delta", "Delta"
local solara, Solara, SOLARA = "Solara", "Solara", "Solara"

-- [[ get devixe ]] --
if getgenv().devixe then
_G.platform = _G.uis:GetPlatform();
_G.IsOnMobile = Enum.Platform.IOS,Enum.Platform.Android;
end;

-- [[ T O & T A B L E S  ]] --
   _G.find = table.find;
_G.num = tonumber;
_G.str = tostring;
_G.lowerkase = string.lower;
_G.kapital = string.upper;
_G.strfind = string.find;

--[[ cframe pos ]]--


   -- [[ servixes 2 ]] --

-- [[ others ]] --
if getgenv().hook and _G.exp ~= SOLARA then
_G.rawmt = getrawmetatable(game);
_G.method = getnamecallmethod();
_G.server, _G.klient, _G.invoke = ("FireServer"), ("FireClient"), ("InvokeServer");
  else 
print("Globals: getgenv().hook = false")
 end; -- if getgenv().hook true (no solara)

-- [[ WRITE MSG ]] --
_G.write = function(msg,typingtime,destroytime)
spawn(function()
local h=Instance.new("Hint");
h.Parent = game.Workspace;
local function typeMessage()
for i=1,#msg do 
h.Text=string.sub(msg,1,i);
if typingtime then wait(typingtime); else wait(.06) end;
  end;
end;
typeMessage();
if destroytime then wait(destroytime); else wait(3.3) end;
h:Destroy(); end)
end;

-- [[ LOLLYPOP HUB NOTIF ]] --
_G.ok = function(text,dur)
_G.sgui:SetCore("SendNotification",{
Title = "Lollypop Hub üç≠",
Duration = dur or 5,
Button1 = "okay",
Callback = function() print('ok'); end,
Text = text});
end;

    --[[ global funks ]]--
if getgenv().tpWalk then
_G.toggleTPWalk = function(value)
tpwalk = value
if value then
tpwalking = game:GetService("RunService").Stepped:Connect(function()
if tpwalk then
local character = game.Players.LocalPlayer.Character
local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
if humanoid and humanoid.MoveDirection.Magnitude>0 then

local moveDirection = humanoid.MoveDirection;
if speed then
character:TranslateBy(moveDirection * speed);
   else
character:TranslateBy(moveDirection)
    end;
  end;
    else
tpwalking:Disconnect()
   end;
 end);
else
tpwalking:Disconnect()
 end;
end;
_G.updateTPWalkSpeed = function(text)
local newSpeed = tonumber(text);
if newSpeed then
local formattedSpeed = string.format("%.1f", newSpeed)
speed = tonumber(formattedSpeed)
text = formattedSpeed;
      else
text = "1"
speed = 1
   end
return text;
  end;
else print("Globals: getgenv().tpWalk = false");
end; -- if getgenv().tpWalk is on

-- [[ FIND PLR BY PARTIAL NAME ]] -- 
_G.findTargetPlr = function(name)
for _, player in ipairs(players:GetPlayers()) do
     if player.DisplayName:lower():find(name:lower()) or player.Name:lower():find(name:lower()) then
if _G.find(_G.immune, player.Name) then
     task.wait(); targetPlayer = nil; 
             return nil;
         else
             return player;
         end
     end;
 end;
 return nil;
end;

--[[ AKALI NOTIF ]]--
_G.note = function(txt, dur)
_G.RRixh = loadstring(game:HttpGet("https://raw.githubusercontent.com/rrixh/uwuware/main/skripts/AkaliNotif", true))();
_G.Notify = _G.RRixh.Notify; _G.Notify({Description = ("Lollypop Hub üç≠\n")..txt, Duration = dur or 7}); 
end;

_G.rnote = function(txt, dur)
_G.RRixh = loadstring(game:HttpGet("https://raw.githubusercontent.com/rrixh/uwuware/main/skripts/AkaliNotif", true))();
_G.Notify = _G.RRixh.Notify; _G.Notify({Description = txt, Duration = dur or 7}); 
end;

-- [[ make BUTTON1 & BUTTON2 FUNKS ]] --
_G.button2 = function(title, text, duration, B1text, B2text, func, func2, assetID)
  local function Callback(answer)
    if answer == B1text then
     if func then func() else _G.rnote("No funktion set for:\n'"..B1text.."' and '"..B2text.."'"); end;
    elseif answer == B2text then
    if func2 then func2() else _G.rnote("No funktion set for:\n'"..B2text.."'"); end;
    end;
  end;

local troll = (7635712200);
local lollypop = (17767487755);
local hublogo = (81697484807530);
local yougay = Instance.new("BindableFunction");
yougay.OnInvoke = Callback;

  local notifData = {
    Title = title or "Title Blank dumbass",
    Text = text or "Text Blank stupid",
    Duration = duration or 15,
    Button1 = B1text or "Button1",
    Button2 = B2text or "Button2",
    Callback = yougay or warn("funktions not set")
  }

  if assetID then
    notifData.Icon = "rbxassetid://"..assetID
-- else
-- notifData.Icon = "rbxassetid://"..lollypop
  end;

  local starterGui = game:GetService("StarterGui")
starterGui:SetCore("SendNotification", notifData)
end; 
--[[ 
** example usage: 
_G.button2("Title Here", "Text Here", 15, "Button1Text", "Button2Text", function1, function2, asset_ID_Here) 
-- without "rbxassetid://"
]]--
--[[end button2 funk]]--

-- [[ perform aktion on player ]] --
_G.doPlr = function(playerName, kallbaxk)
spawn(function()
  local player = game.Players:FindFirstChild(playerName);
  if player then
    kallbaxk(player)
  else
_G.rnote("kant seem to find this nigga '" ..playerName.. "'")
  end;
end); -- spawn the funk faster
end;

--[[ GET NEAREST BODY PART ]]--
if getgenv().nearestbodypart and _G.exp ~= SOLARA then
_G.getNearestPlr = function(bodyPart)
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    local nearestPlayer = nil
    local nearestDistance = math.huge
    bodyPart = bodyPart:lower()
    local bodyParts = {
        head = "Head",
        hrp = "HumanoidRootPart",
        humanoidrootpart = "HumanoidRootPart",
        torso = "Torso",
        leftleg = "Left Leg",
        rightleg = "Right Leg",
        leftarm = "Left Arm",
        rightarm = "Right Arm",
    };
local correctCaseBodyPart = bodyParts[bodyPart]
    if not correctCaseBodyPart then
        print("Invalid body part name")
        return nil
    end;
for _, player in pairs(players:GetPlayers()) do
        if player ~= localPlayer then
            local character = player.Character
            if character and character:FindFirstChild(correctCaseBodyPart) then
                local targetPart = character:FindFirstChild(correctCaseBodyPart)
                local distance = (localPlayer.Character.HumanoidRootPart.Position - targetPart.Position).magnitude
                if distance < nearestDistance then
                    nearestPlayer = player
                    nearestDistance = distance
                end
            end
        end
    end;
    if nearestPlayer and nearestPlayer.Character then
        local nearestPart = nearestPlayer.Character:FindFirstChild(correctCaseBodyPart)
        if nearestPart then
     print("Nearest player: "..nearestPlayer.Name..", Body Part: "..nearestPart.Name)
            return nearestPart
        end
    end;
 return nil;
   end;

else print("Globals: getgenv().nearestbodypart = false")
 end; -- if getgenv().nearestbodypart

-- [[ PROXIMITY PROMPT ]] --
if getgenv().pps and _G.exp ~= SOLARA then
_G.firepp = function(prompt)
local defaultDur = prompt.HoldDuration;
    prompt.HoldDuration = 0;
    prompt:InputHoldBegin();
    prompt:InputHoldEnd();
    prompt.HoldDuration = defaultDur;
    end;
_G.fireprompt = function(...)
local fppname=...
if fppname then
local name = fppname
for _, firedapp in ipairs(game:GetService("Workspace"):GetDescendants()) do
if firedapp:IsA("ProximityPrompt") and firedapp.Name:lower() == name:lower() or firedapp:IsA("ProximityPrompt") and firedapp.Parent.Name:lower() == name:lower() then
fireproximityprompt(firedapp, 1)
end
end
else
for i, v in ipairs(game:GetService("Workspace"):GetDescendants()) do
if v:IsA("ProximityPrompt") then
fireproximityprompt(v, 1)
    end
   end;
  end;
end;
      else 
print("Globals: getgenv().pps = false");
end; -- if getgenv().pps (proximityprompts) is enabled

_G.kopy = function(uh)
setclipboard(uh)
end;

_G.goto = function(id)
game:GetService("TeleportService"):Teleport(id,game:GetService("Players").LocalPlayer)
end;

    _G.bezier = function(t, p0, p1, p2)
    local l1 = p0:Lerp(p1, t)
    local l2 = p1:Lerp(p2, t)
    return l1:Lerp(l2, t)
    end

    _G.tweenTo = function(part, duration)
    local player = game.Players.LocalPlayer
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart");
    if not hrp then return end;
    local startPos = hrp.Position
    local endPos = part.Position
    local midPos = (startPos + endPos) / 2 + Vector3.new(math.random(-5, 5), math.random(3, 7), math.random(-5, 5))
    local tweenStart = os.clock();
    repeat
    local elapsed = os.clock() - tweenStart
    local t = math.min(elapsed / duration, 1)
    local bezierPos = _G.bezier(t, startPos, midPos, endPos);
    hrp.CFrame = CFrame.new(bezierPos)
    task.wait()
    until t >= 1
    end;

    --simulate touxhing part
    _G.touxh = function(part, duration)
    _G.plr = game.Players.LocalPlayer
    _G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
    if not _G.hrp then return end;
    firetouchinterest(_G.hrp, part, 0)
    if duration then task.wait(duration) else task.wait(.1) end;
    firetouchinterest(_G.hrp, part, 1)
    end;

    --tp
    _G.tp = function(part, duration)
    _G.plr = game.Players.LocalPlayer
    _G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
    if not _G.hrp then return end;
    _G.hrp.CFrame = part.CFrame
    if duration then
    task.wait(duration)
        end;
    end;

    _G.bring = function(part, duration)
    _G.player = game.Players.LocalPlayer
    _G.hrp = _G.player.Character and _G.player.Character:FindFirstChild("HumanoidRootPart");
    if not _G.hrp then return end;
    part.CFrame = _G.hrp.CFrame;
        if duration then
            task.wait(duration)
        end;
    end;

    -- moveto
    _G.walkTo = function(part, speed)
    if not part then
    error("You must provide a part to walk to.") 
    return end;

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")

    if not humanoidRootPart or not humanoid then
    error("Humanoid or HumanoidRootPart not found in character.")
    return
    end

    local originalSpeed = humanoid.WalkSpeed

    if type(speed) == "number" then
    humanoid.WalkSpeed = speed
    end

    local PathfindingService = game:GetService("PathfindingService")
    local path = PathfindingService:CreatePath({
    AgentHeight = humanoid.HipHeight * 2,
    AgentRadius = 2,
    AgentCanJump = true,
    })

    path:ComputeAsync(humanoidRootPart.Position, part.Position)
    local waypoints = path:GetWaypoints()

    for _, waypoint in pairs(waypoints) do
    humanoid:MoveTo(waypoint.Position)
    humanoid.MoveToFinished:Wait()

    if waypoint.Action == Enum.PathWaypointAction.Jump then
    humanoid.Jump = true
    end
    end
    -- Restore original walk speed after reaching the target
    humanoid.WalkSpeed = originalSpeed
    end;

    --tpwalk to
    _G.tpwalkTo = function(part, tpWalkDistanxe)
    if not part then
    error("You must provide a part to teleport walk to.")
    return
    end;
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid");
    if not humanoidRootPart or not humanoid then
    error("Humanoid or HumanoidRootPart not found in character.")
    return
    end;
    local stepDistance = 5.6 or tpWalkDistanxe
    local function moveToStep(targetPos)
    humanoidRootPart.CFrame = CFrame.new(targetPos)
    end;
    local startPos = humanoidRootPart.Position
    local endPos = part.Position
    local direction = (endPos - startPos).unit
    local currentPos = startPos;
    while (currentPos - endPos).magnitude > stepDistance do
    currentPos = currentPos + direction * stepDistance
    moveToStep(currentPos)
    task.wait(0.01)
    end;
    moveToStep(endPos)
    end;

    --i pairs
    _G.iPairs = function(part, funk, dur)
    for uh,ipair in ipairs(part:GetChildren()) do
        funk(ipair)
    if dur then wait(dur) end;
      end
    end

    -- pairs
    _G.Pairs = function(part, funk, dur)
    for uh,pair in pairs(part:GetChildren()) do
        funk(pair)
    if dur then wait(dur) end;
      end
    end;

    --[[üñçPREDEFINED KOLORSüñç]]--
    red = "red"
    green = "green"
    blue = "blue"
    yellow = "yellow"
    pink = "pink"
    orange = "orange"
    cyan = "cyan"
    purple = "purple"
    white = "white"
    black = "black"
    gray = "gray"
    brown = "brown"
    lime = "lime"
    magenta = "magenta"
    salmon = "salmon"
    teal = "teal"

    -- highlight part
    local colorVariables = {
      red = "red",
      green = "green",
      blue = "blue",
      yellow = "yellow",
      pink = "pink",
      orange = "orange",
      cyan = "cyan",
      purple = "purple",
      white = "white",
      black = "black",
      gray = "gray",
      brown = "brown",
      lime = "lime",
      magenta = "magenta",
      salmon = "salmon",
      teal = "teal"
    }

    local colorVariables = {
    red = "red",
    green = "green",
    blue = "blue",
    yellow = "yellow",
    pink = "pink",
    orange = "orange",
    cyan = "cyan",
    purple = "purple",
    white = "white",
    black = "black",
    gray = "gray",
    brown = "brown",
    lime = "lime",
    magenta = "magenta",
    salmon = "salmon",
    teal = "teal"
    }

    _G.activeEspObjects = _G.activeEspObjects or {}

    _G.partesp = function(part, colorVar, removeESP)
    if not part or not colorVar then
    error("Missing part or color for ESP")
    return end;
    local colorName = colorVariables[colorVar:lower()]
    if not colorName then
    error("Invalid color variable provided: " .. tostring(colorVar))
    return
    end;
    local colors = {
    red = Color3.fromRGB(255, 0, 0),
    green = Color3.fromRGB(0, 255, 0),
    blue = Color3.fromRGB(0, 0, 255),
    yellow = Color3.fromRGB(255, 255, 0),
    pink = Color3.fromRGB(255, 192, 203),
    orange = Color3.fromRGB(255, 165, 0),
    cyan = Color3.fromRGB(0, 255, 255),
    purple = Color3.fromRGB(128, 0, 128),
    white = Color3.fromRGB(255, 255, 255),
    black = Color3.fromRGB(0, 0, 0),
    gray = Color3.fromRGB(128, 128, 128),
    brown = Color3.fromRGB(165, 42, 42),
    lime = Color3.fromRGB(50, 205, 50),
    magenta = Color3.fromRGB(255, 0, 255),
    salmon = Color3.fromRGB(250, 128, 114),
    teal = Color3.fromRGB(0, 128, 128)
    }
    local espColor = colors[colorName]
    if not espColor then
    error("Invalid color provided in the script")
    return
    end;
    local existingEsp = _G.activeEspObjects[part]
    if existingEsp then
    existingEsp:Destroy()
    end;
    local espHighlight = Instance.new("Highlight")
    espHighlight.Adornee = part
    espHighlight.FillColor = espColor or green
    espHighlight.FillTransparency = 0.15 -- Default to 0.15 transparency
    espHighlight.OutlineTransparency = 0.15 -- Default to 0.15 transparency
    espHighlight.Parent = game:GetService("CoreGui");
    _G.activeEspObjects[part] = espHighlight
    if removeESP then
    spawn(function()
    wait(removeESP)
    espHighlight:Destroy()
    _G.activeEspObjects[part] = nil
    end)
    end;
    end;

    --[[ ROBLOX INNOVATION AWARDS ]]--
    _G.circlet = Workspace:FindFirstChild("Scavenger") and Workspace.Scavenger:FindFirstChild("Circlet")
    _G.stagestand = Workspace:FindFirstChild("CenterPiece") and Workspace.CenterPiece:FindFirstChild("CenterPiece_Stand") and Workspace.CenterPiece.CenterPiece_Stand:FindFirstChild("Meshes/Stand_Full_Cylinder.001")
    _G.B1 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block1")
    _G.B2 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block2")
    _G.B3 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block3")
    _G.B4 = Workspace:FindFirstChild("CubePieces") and Workspace.CubePieces:FindFirstChild("Block4")

    _G.rbxinnovationitems = {
    _G.B1, _G.B2, _G.B3, _G.B4, _G.stagestand, _G.circlet}

    --part traxers
    _G.colorVariables = {
    red = Color3.fromRGB(255, 0, 0),
    green = Color3.fromRGB(0, 255, 0),
    blue = Color3.fromRGB(0, 0, 255),
    yellow = Color3.fromRGB(255, 255, 0),
    pink = Color3.fromRGB(255, 192, 203),
    orange = Color3.fromRGB(255, 165, 0),
    cyan = Color3.fromRGB(0, 255, 255),
    purple = Color3.fromRGB(128, 0, 128),
    white = Color3.fromRGB(255, 255, 255),
    black = Color3.fromRGB(0, 0, 0),
    gray = Color3.fromRGB(128, 128, 128),
    brown = Color3.fromRGB(165, 42, 42),
    lime = Color3.fromRGB(50, 205, 50),
    magenta = Color3.fromRGB(255, 0, 255),
    salmon = Color3.fromRGB(250, 128, 114),
    teal = Color3.fromRGB(0, 128, 128)
    }
    --tracers for part
    _G.activeTracerObjects = _G.activeTracerObjects or {};
    _G.tracers = function(part, colorVar, removeTracer)
    _G.part = part
    _G.colorVar = colorVar
    _G.removeTracer = removeTracer;
    if not _G.part or not _G.colorVar then
    error("Missing part or color for tracer ESP")
    return end;
    _G.tracerColor = _G.colorVariables[_G.colorVar:lower()]
    if not _G.tracerColor then
    error("Invalid color variable provided: " .. tostring(_G.colorVar))
    return end;
    _G.existingTracer = _G.activeTracerObjects[_G.part]
    if _G.existingTracer then
    _G.existingTracer:Destroy()
    end;
    _G.tracer = Instance.new("Beam")
    _G.tracer.Attachment0 = Instance.new("Attachment", _G.part)
    _G.tracer.Attachment1 = Instance.new("Attachment", game.Players.LocalPlayer.Character.Head)
    _G.tracer.Color = ColorSequence.new(_G.tracerColor)
    _G.tracer.Width0 = 0.1
    _G.tracer.Width1 = 0.1
    _G.tracer.Parent = game:GetService("CoreGui");
    _G.activeTracerObjects[_G.part] = _G.tracer;
    if _G.removeTracer then
    spawn(function()
    wait(_G.removeTracer)
    if _G.tracer then
    _G.tracer:Destroy()
    _G.activeTracerObjects[_G.part] = nil
    end;end);end;end;

    -- get child using ipairs 
    _G.ipairs = function(p, funk, dur)
    if not p or not funk then 
warn("nigga! '"..p.."' is an invalid part & u need to provide a valid funktion for: '"..funk.. "'"); return end;
    for lula, thang in ipairs(p:GetChildren()) do
    funk(thang) 
        end;
    if dur then wait(dur) end;
end;

    --get child using pairs
_G.pairs = function(p, funk, dur)
    if not p or not funk then 
warn("nigga! '"..p.."' is an invalid part & u need to provide a valid funktion for: '"..funk.. "'"); return end;
    for lula, thang in pairs(p:GetChildren()) do
    funk(thang) 
        end;
    if dur then wait(dur) end;
end;

-- [[ PART ESP OR HIGHLIGHT ]] --
_G.part = function(part, argument, color)
    if not part then
        warn("Invalid part provided to _G.part. Must be a part instance.")
        return
    end
    if not argument or (argument ~= "studs" and argument ~= "esp") then
        warn("Invalid argument provided to _G.part. Use 'studs' or 'esp'.")
        return
    end

    local partsToModify = {}
    if part:IsA("BasePart") then
        table.insert(partsToModify, part)
    elseif part:IsA("Model") then
        for _, p in pairs(part:GetChildren()) do
            if p:IsA("BasePart") then
                table.insert(partsToModify, p)
            end
        end
    else
        warn("Invalid part type provided to _G.part. Use a BasePart or Model.")
        return
    end

    local success = false
    for _, p in pairs(partsToModify) do
        if argument == "studs" then
            local billboardGui = Instance.new("BillboardGui")
            billboardGui.Parent = p  -- Correctly parent to the BasePart
            billboardGui.Adornee = p
            billboardGui.Size = UDim2.new(0, 100, 0, 40)
            billboardGui.StudsOffset = Vector3.new(0, 3, 0)
            billboardGui.AlwaysOnTop = true

            local textLabel = Instance.new("TextLabel")
            textLabel.Parent = billboardGui
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.TextScaled = true
            textLabel.BackgroundTransparency = 1
            textLabel.TextColor3 = color or Color3.new(1, 1, 1)
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.Text = "Calculating..."
            textLabel.TextSize = 14

            -- p.TextLabel = textLabel -- This line is unnecessary and was causing issues.
            success = true
        elseif argument == "esp" then
            local highlightColor = color or Color3.new(1, 0, 0)
            local highlight = Instance.new("Highlight")
            highlight.Parent = p
            highlight.FillColor = highlightColor
            highlight.OutlineColor = highlightColor
            success = true
        end
    end

    if success and not heartbeatConnected then
        local function updateDistances()
            local player = game.Players.LocalPlayer
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                for _, p in pairs(workspace:GetDescendants()) do
                    if p:IsA("BasePart") and p:FindFirstChild("BillboardGui") then -- Check for BillboardGui instead of TextLabel
                        local distance = (character.HumanoidRootPart.Position - p.Position).Magnitude
                        p.BillboardGui.TextLabel.Text = string.format("Distance: %.2f studs", distance)
                    end
                end
            end
        end
        game:GetService("RunService").Heartbeat:Connect(updateDistances)
        heartbeatConnected = true
    end
end; local heartbeatConnected = (false);

--[[ MAKE DRAGGABLE / input types ]]--
local mobile = Enum.UserInputType.Touch;
local mouse1 = Enum.UserInputType.MouseButton1;
local mousemove = Enum.UserInputType.MouseMovement;
local Ended = Enum.UserInputState.End
local Begin = Enum.UserInputState.Begin

-- [[ üì±~ üíª ~ üñ• ~ ‚å®Ô∏è ]] --
local devixes = { mobile,mouse1,mousemove }
local __ = table.find;

--[[ üÄÑÔ∏è MAKE DRAGGABLE üÄÑÔ∏è ]]--
_G.draggable = function(guiElement)
    local dragging = false
    local dragInput, mousePos, framePos
    local dragThreshold = 1
    local notClicked = false;
    guiElement.InputBegan:Connect(function(input)
        if table.find(devixes, input.UserInputType) then
            dragging = true
            mousePos = input.Position
            framePos = guiElement.Position
            notClicked = false

            input.Changed:Connect(function()
      if input.UserInputState == Ended then
                    dragging = false
                end
            end)
        end
    end)

    guiElement.InputChanged:Connect(function(input)
if __(devixes, input.UserInputType) then
            dragInput = input
        end
    end)
UIS.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - mousePos
            if math.abs(delta.X) >= dragThreshold or math.abs(delta.Y) >= dragThreshold then
                notClicked = true
            end

            if notClicked then
                guiElement.Position = UDim2.new(
                    framePos.X.Scale,
                    framePos.X.Offset + delta.X,
                    framePos.Y.Scale,
                    framePos.Y.Offset + delta.Y
                )
            end
        end
    end); return function() return not dragging and notClicked == false end
end;
-- [[ END DRAG ]] --

-- [[ HITBOX EXPANDER ]] --
if getgenv().hitboxexpander then
_G.updateHitboxes = function()
for _, player in pairs(_G.gplrs) do
if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
if _G.hitboxesEnabled then
rootPart.Size = Vector3.new(tonumber(_G.hitboxSize), tonumber(_G.hitboxSize), tonumber(_G.hitboxSize))
rootPart.Transparency = _G.invisibleHitbox and 1 or _G.normalTransparenxy
rootPart.CanCollide = false
else
rootPart.Size = Vector3.new(2, 2, 1) -- Default size
rootPart.Transparency = 0
rootPart.CanCollide = true
end
end
end
end

_G.ESP = function(player, kolor)
for _, part in pairs(player.Character:GetChildren()) do
if part:IsA"BasePart" then
local esp = Instance.new"BoxHandleAdornment"
esp.Name = "ESP"
esp.AlwaysOnTop = true
esp.ZIndex = 20
esp.Adornee = part
esp.Size = part.Size
esp.Transparency = 0.5
esp.Color3 = Color3.new(.75, 0, 0) or kolor
esp.Parent = part
   end
  end
end;

_G.removeESP = function(player)
for _, part in pairs(player.Character:GetChildren()) do
if part:IsA("BasePart") and part:FindFirstChild("ESP") then
part:FindFirstChild("ESP"):Destroy()
     end;
   end;
end;

_G.highlightPlayers = function()
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
if player ~= game.Players.LocalPlayer and player.Character then
if _G.highlightEnabled then
_G.ESP(player)
else
_G.removeESP(player)
          end
        end
      end
   end;
else print("Globals: getgenv().hitboxexpander = false")
end; -- if getgenv().hitboxexpander enabled

-- [[ PivotTo & CFrame tp ]] --
if getgenv().topart and _G.exp ~= Solara then
_G.topart = function(part, arg, method, distance)
    game=game;CFrame=CFrame;
local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart");
if not hrp then print(tostring(hrp), "not found"); return end;
-- PivotTo --
if method == "pivot" then
if arg == "behind" then
hrp:PivotTo(part:GetPivot() * CFrame.new(0, 0, distance));
elseif arg == "front" then
hrp:PivotTo(part:GetPivot() * CFrame.new(0, 0, -distance));
elseif arg == "above" then
hrp:PivotTo(part:GetPivot() * CFrame.new(0, distance, 0));
elseif arg == "below" then
hrp:PivotTo(part:GetPivot() * CFrame.new(0, -distance, 0));
        end;
     end;
-- CFrame --
if method == "cframe" then
if arg == "behind" then
hrp.CFrame = part.CFrame * CFrame.new(0, 0, distance);
elseif arg == "front" then
hrp.CFrame = part.CFrame * CFrame.new(0, 0, -distance);
elseif arg == "above" then
hrp.CFrame = part.CFrame * CFrame.new(0, distance, 0);
elseif arg == "below" then
hrp.CFrame = part.CFrame * CFrame.new(0, -distance, 0);
          end;
          end;
   end;
else print("Globals: getgenv().topart = false")
end; -- if getgenv().topart is true

-- [[ KOLORS ]] --
if getgenv().kolors then
_G.green = Color3.new(0, 1, 0) -- bright
_G.red = Color3.new(1, 0, 0) -- bright
_G.blue = Color3.new(0, 0, 1)
_G.yellow = Color3.new(1, 1, 0)
_G.cyan = Color3.new(0, 1, 1)
_G.magenta = Color3.new(1, 0, 1)
_G.orange = Color3.new(1, 0.5, 0)
_G.purple = Color3.new(0.5, 0, 0.5)
_G.pink = Color3.new(1, 0.75, 0.8) -- bright
_G.brown = Color3.new(0.6, 0.3, 0)
_G.gray = Color3.new(0.5, 0.5, 0.5)
_G.white = Color3.new(1, 1, 1)
_G.black = Color3.new(0, 0, 0)
_G.lightblue = Color3.new(0.68, 0.85, 0.9)
_G.darkblue = Color3.new(0, 0, 0.55)
_G.lightgreen = Color3.new(0.56, 0.93, 0.56) -- bright af
_G.darkgreen = Color3.new(0, 0.39, 0)
_G.lightred = Color3.new(1, 0.71, 0.76)
_G.darkred = Color3.new(0.55, 0, 0)
_G.lightyellow = Color3.new(1, 1, 0.88)
_G.darkyellow = Color3.new(0.55, 0.55, 0)
_G.lightcyan = Color3.new(0.88, 1, 1)
_G.darkcyan = Color3.new(0, 0.55, 0.55)
_G.lightmagenta = Color3.new(1, 0.88, 1)
_G.darkmagenta = Color3.new(0.55, 0, 0.55)
_G.lightorange = Color3.new(1, 0.75, 0.5)
_G.darkorange = Color3.new(1, 0.55, 0)
_G.lightpurple = Color3.new(0.73, 0.56, 0.81)
_G.darkpurple = Color3.new(0.48, 0.32, 0.64)
_G.lightpink = Color3.new(1, 0.71, 0.76)
_G.darkpink = Color3.new(0.55, 0, 0.55)
_G.lightbrown = Color3.new(0.87, 0.72, 0.53)
_G.darkbrown = Color3.new(0.36, 0.25, 0.2)
_G.lightgray = Color3.new(0.83, 0.83, 0.83)
_G.darkgray = Color3.new(0.33, 0.33, 0.33)
_G.silver = Color3.new(0.75, 0.75, 0.75)
_G.gold = Color3.new(1, 0.84, 0)
_G.skyblue = Color3.new(0.53, 0.81, 0.92)
_G.royalblue = Color3.new(0.25, 0.41, 0.88)
_G.teal = Color3.new(0, 0.5, 0.5)
_G.navy = Color3.new(0, 0, 0.5)
_G.lime = Color3.new(0, 1, 0)
_G.olive = Color3.new(0.5, 0.5, 0)
_G.maroon = Color3.new(0.5, 0, 0)
_G.aqua = Color3.new(0, 1, 1)
_G.fuchsia = Color3.new(1, 0, 1)
_G.khaki = Color3.new(0.94, 0.9, 0.55)
_G.coral = Color3.new(1, 0.5, 0.31)
_G.salmon = Color3.new(0.98, 0.5, 0.45)
_G.indigo = Color3.new(0.29, 0, 0.51)
_G.violet = Color3.new(0.93, 0.51, 0.93)
_G.peach = Color3.new(1, 0.9, 0.71)
_G.tan = Color3.new(0.82, 0.71, 0.55)
_G.seagreen = Color3.new(0.18, 0.55, 0.34)
_G.turquoise = Color3.new(0.25, 0.88, 0.82)
_G.azure = Color3.new(0.94, 1, 1)
_G.beige = Color3.new(0.96, 0.96, 0.86)
_G.lavender = Color3.new(0.9, 0.9, 0.98)
_G.plum = Color3.new(0.87, 0.63, 0.87)
_G.crimson = Color3.new(0.86, 0.08, 0.24)
_G.sienna = Color3.new(0.63, 0.32, 0.18)
_G.raspberry = Color3.new(0.89, 0.04, 0.36)
_G.chocolate = Color3.new(0.82, 0.41, 0.12)
_G.copper = Color3.new(0.72, 0.45, 0.2)
_G.ruby = Color3.new(0.88, 0.07, 0.37)
_G.mint = Color3.new(0.6, 1, 0.6)
_G.cerulean = Color3.new(0.01, 0.48, 0.65)
_G.mauve = Color3.new(0.88, 0.69, 1)
_G.amber = Color3.new(1, 0.75, 0)
_G.ochre = Color3.new(0.8, 0.47, 0.13)
_G.jade = Color3.new(0, 0.66, 0.42)
_G.rose = Color3.new(1, 0.89, 0.88)
_G.sapphire = Color3.new(0.06, 0.32, 0.73)
_G.cream = Color3.new(1, 0.99, 0.82)
_G.amethyst = Color3.new(0.6, 0.4, 0.8)
_G.periwinkle = Color3.new(0.8, 0.8, 1)
_G.moss = Color3.new(0.68, 0.87, 0.68)
_G.lilac = Color3.new(0.78, 0.64, 0.78)
_G.chartreuse = Color3.new(0.5, 1, 0)
_G.wisteria = Color3.new(0.79, 0.63, 0.86)
_G.blush = Color3.new(0.87, 0.36, 0.51)
_G.sand = Color3.new(0.76, 0.7, 0.5)
_G.burgundy = Color3.new(0.5, 0, 0.13)
_G.honeydew = Color3.new(0.94, 1, 0.94)
_G.peacock = Color3.new(0.2, 0.63, 0.79)
_G.almond = Color3.new(0.94, 0.87, 0.8)
_G.eggplant = Color3.new(0.38, 0.25, 0.32) -- good‚úÖ
_G.bubblegum = Color3.new(1, 0.75, 0.8)
_G.merlot = Color3.new(0.45, 0.19, 0.22)
_G.limegreen = Color3.new(0.2, 0.8, 0.2)
_G.bronze = Color3.new(0.8, 0.5, 0.2)
_G.cobalt = Color3.new(0, 0.28, 0.67)
_G.carrot = Color3.new(0.93, 0.57, 0.13)
_G.denim = Color3.new(0.08, 0.38, 0.74)
_G.mulberry = Color3.new(0.77, 0.29, 0.55)
_G.slate = Color3.new(0.44, 0.5, 0.56)
_G.brick = Color3.new(0.61, 0.4, 0.12)
_G.ice = Color3.new(0.88, 1, 1)
_G.marine = Color3.new(0.04, 0.2, 0.27)
_G.sepia = Color3.new(0.44, 0.26, 0.08)
_G.rust = Color3.new(0.72, 0.25, 0.05)
_G.eggcream = Color3.new(1, 0.94, 0.84)
_G.blizzard = Color3.new(0.9, 0.98, 1)
_G.butterscotch = Color3.new(1, 0.78, 0.49)
_G.mahogany = Color3.new(0.75, 0.25, 0)
_G.springgreen = Color3.new(0, 1, 0.5)
_G.carnation = Color3.new(1, 0.65, 0.79)
_G.fern = Color3.new(0.31, 0.47, 0.26)
_G.cerise = Color3.new(0.87, 0.19, 0.39)
_G.ash = Color3.new(0.7, 0.75, 0.71)
_G.cornflower = Color3.new(0.39, 0.58, 0.93)
_G.seashell = Color3.new(1, 0.96, 0.93)
_G.mintcream = Color3.new(0.96, 1, 0.98)
_G.tangerine = Color3.new(1, 0.6, 0)
_G.vermilion = Color3.new(0.89, 0.26, 0.2)
_G.rainforest = Color3.new(0.09, 0.5, 0.33)
_G.rouge = Color3.new(0.74, 0.23, 0.29)
_G.pumpkin = Color3.new(1, 0.46, 0.09)
_G.powderblue = Color3.new(0.69, 0.88, 0.9)
_G.sunglow = Color3.new(1, 0.8, 0.2)
_G.pear = Color3.new(0.82, 0.89, 0.19)
_G.fog = Color3.new(0.94, 0.94, 0.94)
_G.kiwi = Color3.new(0.56, 0.93, 0.56)
_G.iris = Color3.new(0.35, 0.31, 0.81)
_G.pistachio = Color3.new(0.58, 0.77, 0.45)
_G.cherry = Color3.new(0.87, 0.19, 0.39)
_G.mimosa = Color3.new(1, 0.74, 0.47)
_G.saffron = Color3.new(0.96, 0.77, 0.19)
_G.malachite = Color3.new(0.04, 0.85, 0.32)
_G.juniper = Color3.new(0.18, 0.31, 0.31)
_G.ivory = Color3.new(1, 1, 0.94)
_G.forest = Color3.new(0.13, 0.55, 0.13)
_G.marineblue = Color3.new(0.01, 0.27, 0.49)
_G.ocean = Color3.new(0.0, 0.53, 0.74)
_G.silver = Color3.new(0.75, 0.75, 0.75)
_G.macaroon = Color3.new(1, 0.85, 0.7)
_G.cantaloupe = Color3.new(1, 0.6, 0.4)
_G.lichen = Color3.new(0.74, 0.93, 0.59)
_G.onyx = Color3.new(0.06, 0.06, 0.06)
_G.irisblue = Color3.new(0.33, 0.5, 1)
_G.pearl = Color3.new(0.94, 0.92, 0.84)
_G.coral = Color3.new(1, 0.5, 0.31)
_G.orchid = Color3.new(0.85, 0.44, 0.84)
_G.salmon = Color3.new(0.98, 0.5, 0.45)
_G.oldlace = Color3.new(0.99, 0.96, 0.9)
_G.lime = Color3.new(0.75, 1, 0)
_G.olive = Color3.new(0.5, 0.5, 0)
_G.teal = Color3.new(0, 0.5, 0.5)
_G.navy = Color3.new(0, 0, 0.5)
_G.fuchsia = Color3.new(1, 0, 1)
_G.maroon = Color3.new(0.5, 0, 0)
_G.aqua = Color3.new(0, 1, 1)
_G.cyan = Color3.new(0, 1, 1)
_G.magenta = Color3.new(1, 0, 1)
_G.gold = Color3.new(1, 0.84, 0)
_G.khaki = Color3.new(0.94, 0.9, 0.55)
_G.lavenderblush = Color3.new(1, 0.94, 0.96)
_G.lemonchiffon = Color3.new(1, 0.98, 0.8)
_G.lightblue = Color3.new(0.68, 0.85, 0.9)
_G.lightcoral = Color3.new(0.94, 0.5, 0.5)
_G.lightcyan = Color3.new(0.88, 1, 1)
_G.lightgoldenrodyellow = Color3.new(0.98, 0.98, 0.82)
_G.lightgray = Color3.new(0.83, 0.83, 0.83)
_G.lightgreen = Color3.new(0.56, 0.93, 0.56)
_G.lightpink = Color3.new(1, 0.71, 0.76)
_G.lightsalmon = Color3.new(1, 0.63, 0.48)
_G.lightseagreen = Color3.new(0.13, 0.7, 0.67)
_G.lightskyblue = Color3.new(0.53, 0.81, 0.98)
_G.lightslategray = Color3.new(0.47, 0.53, 0.6)
_G.lightsteelblue = Color3.new(0.69, 0.77, 0.87)
_G.lightyellow = Color3.new(1, 1, 0.88)
     else 
print("Globals: getgenv().kolors = false")
end;
-- [[ END OF KOLORS ]] --

end); --[[protekted kall]]--
if not globals then
warn("Globals error okkured:", syntaxerror);
else 
print("Globals:", globals, "‚úÖ")
end;