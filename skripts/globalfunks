-- global funk skript
_G.bezier = function(t, p0, p1, p2)
local l1 = p0:Lerp(p1, t)
local l2 = p1:Lerp(p2, t)
return l1:Lerp(l2, t)
end

_G.tweenTo = function(part, duration, dur)
local player = game.Players.LocalPlayer
local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart");
if not hrp then return end;
local startPos = hrp.Position
local endPos = part.Position
local midPos = (startPos + endPos) / 2 + Vector3.new(math.random(-5, 5), math.random(3, 7), math.random(-5, 5))
local tweenStart = os.clock();
repeat
local elapsed = os.clock() - tweenStart
local t = math.min(elapsed / duration, 1)
local bezierPos = _G.bezier(t, startPos, midPos, endPos);
hrp.CFrame = CFrame.new(bezierPos)
if dur then task.wait(dur) end;
until t >= 1
end;

--simulate touxhing part
_G.touxh = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
firetouchinterest(_G.hrp, part, 0)
if duration then
task.wait(duration)
end;
firetouchinterest(_G.hrp, part, 1)
end;

--tp
_G.tp = function(part, duration)
_G.plr = game.Players.LocalPlayer
_G.hrp = _G.plr.Character and _G.plr.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
_G.hrp.CFrame = part.CFrame
if duration then
task.wait(duration)
    end;
end;

_G.bring = function(part, duration)
_G.player = game.Players.LocalPlayer
_G.hrp = _G.player.Character and _G.player.Character:FindFirstChild("HumanoidRootPart");
if not _G.hrp then return end;
part.CFrame = _G.hrp.CFrame;
    if duration then
        task.wait(duration)
    end;
end;

-- moveto
_G.walkTo = function(part, speed)
if not part then
error("You must provide a part to walk to.") 
return end;

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid")

if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end

local originalSpeed = humanoid.WalkSpeed

if type(speed) == "number" then
humanoid.WalkSpeed = speed
end

local PathfindingService = game:GetService("PathfindingService")
local path = PathfindingService:CreatePath({
AgentHeight = humanoid.HipHeight * 2,
AgentRadius = 2,
AgentCanJump = true,
})

path:ComputeAsync(humanoidRootPart.Position, part.Position)
local waypoints = path:GetWaypoints()

for _, waypoint in pairs(waypoints) do
humanoid:MoveTo(waypoint.Position)
humanoid.MoveToFinished:Wait()

if waypoint.Action == Enum.PathWaypointAction.Jump then
humanoid.Jump = true
end
end
-- Restore original walk speed after reaching the target
humanoid.WalkSpeed = originalSpeed
end;

--tpwalkto
_G.tpwalkTo = function(part)
if not part then
error("You must provide a part to teleport walk to.")
return
end;
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local humanoid = character:FindFirstChildWhichIsA("Humanoid");
if not humanoidRootPart or not humanoid then
error("Humanoid or HumanoidRootPart not found in character.")
return
end;
local stepDistance = 7
local function moveToStep(targetPos)
humanoidRootPart.CFrame = CFrame.new(targetPos)
end;
local startPos = humanoidRootPart.Position
local endPos = part.Position
local direction = (endPos - startPos).unit
local currentPos = startPos;
while (currentPos - endPos).magnitude > stepDistance do
currentPos = currentPos + direction * stepDistance
moveToStep(currentPos)
task.wait(0.01)
end;
moveToStep(endPos)
end;

--iterate thru parts in pairs w/funk
_G.iPairs = function(parts, kallbaxk, dur)
for _, part in ipairs(parts) do
        kallbaxk(part)
if dur then wait(dur) end;
    end;
end;

-- find parts in pairs w/funk
_G.Pairs = function(parts,kallbaxk,dur)
for _, part in pairs(parts) do
     kallbaxk(part)
if dur then wait(dur) end;
    end;
end;